<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>Er Zevillano contra el Mundo</title>
	<style>
		body { margin: 0; padding: 0; font-size: 0; }
		canvas { width: 100%; height: 100%; }
	</style>
</head>
<body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/84/three.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/annyang/2.6.0/annyang.min.js"></script>

<script>

    if (annyang) {
        // Let's define a command.
        var commands = {
            'hola': function() {
                console.log("HOLA");
                alert('Hello world!');
            },
						'gira': function() {
							console.log("Gira");
							rotationEnabled = true;
						},
						'para' : function() {
							console.log("Para");
							rotationEnabled = false;
						},
						'rojo': function() {
							console.log("rojo");
							cube.material.color.setHex( 0xff0000 );
						},
						'verde': function() {
							console.log("verde");
							cube.material.color.setHex( 0x00ff00 );
						},
						'azul': function() {
							console.log("azul");
							cube.material.color.setHex( 0x0000ff );
						},
        };

        // Add our commands to annyang
        annyang.addCommands(commands);
		annyang.setLanguage("es-ES");
        // Start listening.
        annyang.start();
    }


    // MAIN

    // standard global variables
    var container, scene, camera, renderer, cube, stats;
    var clock = new THREE.Clock();

    // custom global variables
    var annie, boomer; // animators
		var rotation = 0;
		var rotationEnabled = false;

    init();
    animate();

    // FUNCTIONS
    function init()
    {
        // SCENE
        scene = new THREE.Scene();
        // CAMERA
        var SCREEN_WIDTH = window.innerWidth, SCREEN_HEIGHT = window.innerHeight;
        var VIEW_ANGLE = 45;
        var ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT;
        var NEAR = 0.1;
		var FAR = 20000;

        camera = new THREE.PerspectiveCamera( VIEW_ANGLE, ASPECT, NEAR, FAR);
        scene.add(camera);
        camera.position.set(0,150,400);
        camera.lookAt(scene.position);



        // RENDERER
        renderer = new THREE.WebGLRenderer({antialias:true});
        renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
        renderer.setClearColor(0xDDDDDD, 1);
        document.body.appendChild(renderer.domElement);

		//CUBE

		var boxGeometry = new THREE.BoxGeometry(30, 30, 30);
		var basicMaterial = new THREE.MeshBasicMaterial({color: 0x0095DD});
		cube = new THREE.Mesh(boxGeometry, basicMaterial);
		scene.add(cube);

        // LIGHT
        var light = new THREE.PointLight(0xffffff);
        light.position.set(0,250,0);
        scene.add(light);
        // FLOOR

        ////////////
        // CUSTOM //
        ////////////

        // MESHES WITH ANIMATED TEXTURES!

        var runnerTexture = new THREE.ImageUtils.loadTexture( 'img/run.png' );
        annie = new TextureAnimator( runnerTexture, 10, 1, 10, 75 ); // texture, #horiz, #vert, #total, duration.
        var runnerMaterial = new THREE.MeshBasicMaterial( { map: runnerTexture, side: THREE.DoubleSide } );
        var runnerGeometry = new THREE.PlaneGeometry(50, 50, 1, 1);
        var runner = new THREE.Mesh(runnerGeometry, runnerMaterial);
        runner.position.set(-100,25,0);
        scene.add(runner);

    }

    function animate()
    {
        requestAnimationFrame( animate );
        render();
        update();
    }

    function update()
    {
        var delta = clock.getDelta();
				if (rotationEnabled){
						rotation += 0.05;
						cube.rotation.set(0.4, rotation, 0);
				}

        annie.update(1000 * delta);
    }

    function render()
    {
        renderer.render( scene, camera );
    }

    function TextureAnimator(texture, tilesHoriz, tilesVert, numTiles, tileDispDuration)
    {
        // note: texture passed by reference, will be updated by the update function.

        this.tilesHorizontal = tilesHoriz;
        this.tilesVertical = tilesVert;
        // how many images does this spritesheet contain?
        //  usually equals tilesHoriz * tilesVert, but not necessarily,
        //  if there at blank tiles at the bottom of the spritesheet.
        this.numberOfTiles = numTiles;
        texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
        texture.repeat.set( 1 / this.tilesHorizontal, 1 / this.tilesVertical );

        // how long should each image be displayed?
        this.tileDisplayDuration = tileDispDuration;

        // how long has the current image been displayed?
        this.currentDisplayTime = 0;

        // which image is currently being displayed?
        this.currentTile = 0;

        this.update = function( milliSec )
        {
            this.currentDisplayTime += milliSec;
            while (this.currentDisplayTime > this.tileDisplayDuration)
            {
                this.currentDisplayTime -= this.tileDisplayDuration;
                this.currentTile++;
                if (this.currentTile == this.numberOfTiles)
                    this.currentTile = 0;
                var currentColumn = this.currentTile % this.tilesHorizontal;
                texture.offset.x = currentColumn / this.tilesHorizontal;
                var currentRow = Math.floor( this.currentTile / this.tilesHorizontal );
                texture.offset.y = currentRow / this.tilesVertical;
            }
        };
    }


    render();
</script>
</body>
</html>
